`timescale 1ns / 1ps
// Generated by CIRCT firtool-1.62.1-1-gdf5ed6ea5
module UartTXCore(
  input        clock,
               reset,
  output       io_txd,
               io_channel_ready,
  input        io_channel_valid,
  input  [7:0] io_channel_bits,
  output       io_busy
);

  reg  [1:0] state;
  reg  [7:0] data;
  reg        tick;
  reg  [2:0] bitCounter;
  reg  [9:0] tickCounter;
  wire       _GEN = state == 2'h1;
  wire       _GEN_0 = state == 2'h2;
  always @(posedge clock) begin
    automatic logic _GEN_1;
    _GEN_1 = _GEN_0 & tick;
    if (reset) begin
      state <= 2'h0;
      tick <= 1'h0;
      bitCounter <= 3'h0;
      tickCounter <= 10'h0;
    end
    else begin
      automatic logic _tick_T_1 = tickCounter == 10'h363;
      if (|state) begin
        if (_GEN) begin
          if (tick) begin
            state <= 2'h2;
            bitCounter <= 3'h0;
          end
        end
        else begin
          if (_GEN_0) begin
            if (tick & (&bitCounter))
              state <= 2'h3;
          end
          else if ((&state) & tick)
            state <= 2'h0;
          if (~_GEN_1 | (&bitCounter)) begin
          end
          else
            bitCounter <= bitCounter + 3'h1;
        end
      end
      else if (io_channel_valid)
        state <= 2'h1;
      tick <= _tick_T_1;
      if (_tick_T_1)
        tickCounter <= 10'h0;
      else
        tickCounter <= tickCounter + 10'h1;
    end
    if (|state) begin
      if (_GEN | ~_GEN_1 | (&bitCounter)) begin
      end
      else
        data <= {1'h0, data[7:1]};
    end
    else if (io_channel_valid)
      data <= io_channel_bits;
  end // always @(posedge)
  assign io_txd = ~(|state) | ~_GEN & (~_GEN_0 | data[0]);
  assign io_channel_ready = ~(|state);
  assign io_busy = |state;
endmodule

module UartRXCore(
  input        clock,
               reset,
               io_rxd,
  output       io_channel_valid,
  output [7:0] io_channel_bits,
  output       io_error
);

  reg  [1:0] state;
  reg  [7:0] data;
  reg        tick;
  reg  [2:0] bitCounter;
  reg  [9:0] tickCounter;
  reg        rxd_REG;
  reg        rxd;
  wire       _GEN = state == 2'h0;
  wire       _GEN_0 = state == 2'h1;
  wire       _GEN_1 = state == 2'h2;
  wire       _GEN_2 = _GEN | _GEN_0 | _GEN_1;
  wire       _GEN_3 = (&state) & tick;
  always @(posedge clock) begin
    automatic logic _GEN_4;
    _GEN_4 = _GEN_1 & tick;
    if (reset) begin
      state <= 2'h0;
      tick <= 1'h0;
      bitCounter <= 3'h0;
      tickCounter <= 10'h0;
    end
    else begin
      automatic logic            _tick_T_1 = tickCounter == 10'h363;
      automatic logic [3:0][1:0] _GEN_5 =
        {{_GEN_3 ? 2'h0 : state},
         {tick & (&bitCounter) ? 2'h3 : state},
         {tick ? 2'h2 : state},
         {rxd ? state : 2'h1}};
      state <= _GEN_5[state];
      tick <= _tick_T_1;
      if (~_GEN) begin
        if (_GEN_0) begin
          if (tick)
            bitCounter <= 3'h0;
        end
        else if (~_GEN_4 | (&bitCounter)) begin
        end
        else
          bitCounter <= bitCounter + 3'h1;
      end
      if (_tick_T_1)
        tickCounter <= 10'h0;
      else
        tickCounter <= tickCounter + 10'h1;
    end
    if (_GEN | _GEN_0 | ~_GEN_4) begin
    end
    else
      data <= {rxd, data[7:1]};
    rxd_REG <= io_rxd;
    rxd <= rxd_REG;
  end // always @(posedge)
  assign io_channel_valid = ~_GEN_2 & (&state) & tick;
  assign io_channel_bits = data;
  assign io_error = ~_GEN_2 & _GEN_3 & ~rxd;
endmodule

module UartCore(
  input        clock,
               reset,
  output       io_tx_txd,
               io_tx_channel_ready,
  input        io_tx_channel_valid,
  input  [7:0] io_tx_channel_bits,
  output       io_tx_busy,
  input        io_rx_rxd,
               io_rx_channel_ready,
  output       io_rx_channel_valid,
  output [7:0] io_rx_channel_bits,
  output       io_rx_error
);

  UartTXCore tx (
    .clock            (clock),
    .reset            (reset),
    .io_txd           (io_tx_txd),
    .io_channel_ready (io_tx_channel_ready),
    .io_channel_valid (io_tx_channel_valid),
    .io_channel_bits  (io_tx_channel_bits),
    .io_busy          (io_tx_busy)
  );
  UartRXCore rx (
    .clock            (clock),
    .reset            (reset),
    .io_rxd           (io_rx_rxd),
    .io_channel_valid (io_rx_channel_valid),
    .io_channel_bits  (io_rx_channel_bits),
    .io_error         (io_rx_error)
  );
endmodule

